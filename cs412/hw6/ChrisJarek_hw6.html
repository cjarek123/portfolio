<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>HW 6 Ray Tracing</title>
    <style>
        body { 
            margin: 0; 
            background: #111; 
            color: #ccc;
            font-family: monospace;
            padding: 20px;
        }
        textarea {
            background: #222;
            color: #0f0;
            font: 14px monospace;
            width: 800px;
            height: 600px;
        }
        canvas {
            border: 1px solid #444;
        }
        .container {
            display: flex;
            gap: 20px;
            align-items: flex-start;
        }

        .canvas-container {
            display: flex;
            flex-direction: column;
        }

        .editor-panel {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .controls {
            margin-top: 10px;
        }
        .controls label {
            display: block;
            margin: 5px 0;
        }
    </style>
</head>
<body>

<h2>HW 6 Ray Tracing</h2>
<p>Edit vertex and fragment shaders on the left, and you can see the result on the right instantly. <br>
Please copy your edits to the source code if you want to save them, as the playground doesn't save them to the file.</p>

<div class="container">
    <div class="canvas-container">
        <canvas id="glCanvas" width="800" height="600"></canvas>
        <button style="width: 100px;" onclick="addObject()">New Object</button>
        <table style="margin-top: 10px; border-collapse: collapse;">
            <thead>
                <tr>
                    <th>Shape</th><th>Material</th><th>Scale</th>
                    <th>X</th><th>Y</th><th>Z</th><th>Color</th><th>Delete</th>
                </tr>
            </thead>
            <tbody id="objectsTable"></tbody>
        </table>
    </div>
    <div class="editor-panel">
         <div>
            <b>Fragment Shader</b><br>
            <textarea id="fsEditor"></textarea>
        </div>
        <div>
            <b>Vertex Shader</b><br>
            <textarea id="vsEditor"></textarea>
        </div>
    </div>
</div>
    
<script>
    //let gl, program;
    let objects = [];

    let objectUniforms = {
        shape: null,
        positions: null,
        scales: null,
        colors: null,
        materials: null,
        count: null
    };

    function initObjectUniforms(gl, program){
        objectUniforms.shape = gl.getUniformLocation(program, 'u_objectShapes');
        objectUniforms.positions = gl.getUniformLocation(program, 'u_objectPositions');
        objectUniforms.scales = gl.getUniformLocation(program, 'u_objectScales');
        objectUniforms.colors = gl.getUniformLocation(program, 'u_objectColors');
        objectUniforms.materials = gl.getUniformLocation(program, 'u_objectMaterials');
        objectUniforms.count = gl.getUniformLocation(program, 'u_objectCount');
    }

    function hexToRGB(hex){
        const r = parseInt(hex.slice(1, 3), 16) / 255;
        const g = parseInt(hex.slice(3, 5), 16) / 255;
        const b = parseInt(hex.slice(5, 7), 16) / 255;
        return [r, g, b];
    }

    function addObject(){
        const container = document.getElementById("objectsTable");

        const row = document.createElement("tr");
        row.innerHTML = `
            <td>
                <select onchange="updateObjects()">
                    <option value="0">Sphere</option>
                    <option value="1">Cube</option>
                </select>
            </td>
            <td>
                <select onchange="updateObjects()">
                    <option value="0">Matte</option>
                    <option value="1">Mirror</option>
                    <option value="2">Metallic</option>
                    <option value="3">Glass</option>
                    <option value="4">Water</option>
                    <option value="5">Lightsource</option>
                </select>
            </td>
            <td><input type="number" onchange="updateObjects()" min="0.01" max="2.0", step="0.01" placeholder="scale" value="1.0"></td>
            <td><input type="number" onchange="updateObjects()" min="-1" max="1" step="0.01" placeholder="x-pos" value="0.0"/></td>
            <td><input type="number" onchange="updateObjects()" min="-1" max="1" step="0.01" placeholder="y-pos" value="0.0"/></td>
            <td><input type="number" onchange="updateObjects()" min="-1" max="1" step="0.01" placeholder="z-pos" value="0.0"/></td>
            <td><input type="color" onchange="updateObjects()" style="width: 20px; height: 20px;" value="#ff0000"/></td>
            <td><button onclick="deleteObject(this)">Delete</button></td>
        `;
        container.appendChild(row);
        updateObjects();
    }

    function deleteObject(obj){
        const row = obj.closest("tr");
        row.remove();
        updateObjects();
    }

    function collectObjects(){
        objects = [];
        //each row has the following cellIndices:
        //0 -> shape selector
        //1 -> material selector
        //2 -> scale
        //3 -> x position
        //4 -> y position
        //5 -> z position
        //6 -> color picker
        //7 -> delete button

        const tbody = document.getElementById("objectsTable");
        const rows = tbody.querySelectorAll("tr");

        rows.forEach((row) => {
            const cells = row.querySelectorAll("td");
            const shape = cells[0].querySelector("select").value;
            const material = cells[1].querySelector("select").value;
            const scale = parseFloat(cells[2].querySelector("input").value);
            const xPos = parseFloat(cells[3].querySelector("input").value);
            const yPos = parseFloat(cells[4].querySelector("input").value);
            const zPos = parseFloat(cells[5].querySelector("input").value);
            const colorHex = cells[6].querySelector("input").value;
            const colorRGB = hexToRGB(colorHex);

            objects.push({
                shape: shape,
                material: material,
                scale: scale,
                position: [xPos, yPos, zPos],
                color: colorRGB
            });
        });
    }

    function updateObjects(){
        collectObjects();

        const maxObjects = 10;
        const shapes = new Int32Array(maxObjects);
        const positions = new Float32Array(maxObjects * 3);
        const scales = new Float32Array(maxObjects);
        const colors = new Float32Array(maxObjects * 3);
        const materials = new Int32Array(maxObjects);
        let count = 0;

        objects.forEach((obj, i) => {
            if(i < maxObjects){
                shapes[i] = obj.shape;

                positions[i * 3 + 0] = obj.position[0];
                positions[i * 3 + 1] = obj.position[1];
                positions[i * 3 + 2] = obj.position[2];

                scales[i] = obj.scale;

                colors[i * 3 + 0] = obj.color[0];
                colors[i * 3 + 1] = obj.color[1];
                colors[i * 3 + 2] = obj.color[2];

                materials[i] = obj.material;
                
                count++;
            }
        });

        if(gl && objectUniforms.positions){
            gl.uniform1iv(objectUniforms.shape, shapes);
            gl.uniform3fv(objectUniforms.positions, positions);
            gl.uniform1fv(objectUniforms.scales, scales);
            gl.uniform3fv(objectUniforms.colors, colors);
            gl.uniform1iv(objectUniforms.materials, materials);
            gl.uniform1i(objectUniforms.count, count);

            render();
        }
    }
</script>>

<script id="vertex-shader" type="x-shader/x-vertex">#version 300 es
    in vec2 position;
    void main() {
        gl_Position = vec4(position, 0.0, 1.0);
    }
</script>

<script id="fragment-shader" type="x-shader/x-fragment">#version 300 es
    precision highp float;

    //dynamic objects uniforms
    uniform int u_objectShapes[10];
    uniform vec3 u_objectPositions[10];
    uniform float u_objectScales[10];
    uniform vec3 u_objectColors[10];
    uniform int u_objectMaterials[10];
    uniform int u_objectCount;

    //time for animation
    uniform float u_time;
    uniform vec2 u_resolution;
    uniform int u_maxBounces;
    uniform float u_ambientStrength;

    out vec4 fragColor;

    // Material types
    const int LIGHT_SOURCE = -1;
    const int MATERIAL_DIFFUSE = 0;
    const int MATERIAL_REFLECTIVE = 1;
    const int MATERIAL_REFRACTIVE = 2;

    // Ray structure
    struct Ray {
        vec3 origin;
        vec3 direction;
    };

    // Sphere structure
    struct Sphere {
        vec3 center;
        float radius;
        vec3 color;
        int material;
        float reflectivity;
        float refractiveIndex;
    };

    // Cube structure
    struct Cube {
        vec3 center;
        vec3 size;
        vec3 color;
        int material;
        float reflectivity;
        float refractiveIndex;
    };

    // Hit record structure
    struct HitData {
        bool hit;
        float t;
        vec3 point;
        vec3 normal;
        vec3 color;
        int material;
        float reflectivity;
        float refractiveIndex;
        bool frontFace;
    };

    // Scene objects
    Sphere spheres[10];
    Sphere lightSphere;
    Cube walls[5];
    Cube cubes[10];

    // Initialize scene objects
    void initScene(float time) {
        // Light sphere
        lightSphere = Sphere(
            vec3(-0.4, 0.4, 0.0), //vec3 center
            0.05,//float radius
            vec3(1, 0.5, 0.05), //vec3 color
            LIGHT_SOURCE,  //int material
            0.5,//float reflectivity
            0.5 //float refractiveIndex
        );

        for(int i = 0; i < walls.length(); i++){
            vec3 position = vec3(1.0, 1.0, 1.0);
            vec3 size = vec3(2.0, 2.0, 2.0);
            if(i == 0){//left wall
                position = position*vec3(-1.0, 0.0, 0.0);
                size = size*vec3(0.05, 1.0, 1.0);
            }
            if(i == 1){//right wall
                position = position*vec3(1.0, 0.0, 0.0);
                size = size*vec3(0.05, 1.0, 1.0);
            }
            if(i == 2){//bottom wall
                position = position*vec3(0.0, -1.0, 0.0);
                size = size*vec3(1.0, 0.05, 1.0);
            }
            if(i == 3){//top wall
                position = position*vec3(0.0, 1.0, 0.0);
                size = size*vec3(1.0, 0.05, 1.0);
            }
            if(i == 4){//back wall
                position = position*vec3(0.0, 0.0, -1.0);
                size = size*vec3(1.0, 1.0, 0.05);
            }

            walls[i] = Cube(
                position, //vec3 center
                size, //vec3 size
                vec3(0.5, 0.5, 0.5), //vec3 color
                MATERIAL_REFLECTIVE, //int material
                0.75, //float reflectivity
                0.0 //float refractiveIndex
            );
        }
        
        int sphereIDX = 0;
        int cubeIDX = 0;
        for(int i = 0; i < u_objectCount; i++){
            int shape = u_objectShapes[i]; //0: sphere, 1: cube
            vec3 position = u_objectPositions[i];
            float scale = u_objectScales[i];
            vec3 color = u_objectColors[i];
            int mat = u_objectMaterials[i];

            int material;
            float reflectivity;
            float refractiveIndex;
            
            switch (mat){
                case 0: //Matte
                    material = MATERIAL_DIFFUSE;
                    reflectivity = 0.0;
                    refractiveIndex = 1.0;
                    break;
                case 1: //Mirror
                    material = MATERIAL_REFLECTIVE;
                    reflectivity = 0.9;
                    refractiveIndex = 1.0;
                    break;
                case 2: //Metallic
                    material = MATERIAL_REFLECTIVE;
                    reflectivity = 0.1;
                    refractiveIndex = 1.0;
                    break;
                case 3: //Glass
                    material = MATERIAL_REFRACTIVE;
                    reflectivity = 0.7;
                    refractiveIndex = 1.7;
                    break;
                case 4: //Water
                    material = MATERIAL_REFRACTIVE;
                    reflectivity = 0.5;
                    refractiveIndex = 1.33;
                    break;
                case 5: //Lightsource
                    material = LIGHT_SOURCE;
                    reflectivity = 0.5;
                    refractiveIndex = 1.0;
                    break;
                default:
                    material = MATERIAL_DIFFUSE;
                    reflectivity = 0.0;
                    refractiveIndex = 1.0;
            }


            if(shape == 0){
                spheres[sphereIDX] = Sphere(
                    u_objectPositions[i],   //vec3 center
                    u_objectScales[i]*0.2,  //float radius
                    u_objectColors[i],      //vec3 color
                    material,               //int material
                    reflectivity,           //float reflectivity
                    refractiveIndex         //float refractiveIndex
                );
                sphereIDX++;
            }else{
                cubes[cubeIDX] = Cube(
                    u_objectPositions[i],   //vec3 center
                    u_objectScales[i]*vec3(0.4, 0.4, 0.4), //vec3 size
                    u_objectColors[i],      //vec3 color
                    material,               //int material
                    reflectivity,           //float reflectivity
                    refractiveIndex         //float refractiveIndex
                );
                cubeIDX++;
            }
        }
        
        //cube
        cubes[9] = Cube(
            vec3(sin(u_time)*0.5-0.25, 0.0, 0.0), //vec3 center
            vec3(0.1, 0.1, 0.1), //vec3 size
            vec3(1.0, 0.0, 0.0), //vec3 color
            MATERIAL_DIFFUSE, //int material
            0.3, //float reflectivity
            0.5 //float refractiveIndex
        );

        cubes[8] = Cube(
            vec3(0.0, 0.0, 0.25), //vec3 center
            vec3(0.5, 0.5, 0.5), //vec3 size
            vec3(0.005, 0.0, 0.005), //vec3 color
            MATERIAL_REFRACTIVE, //int material
            0.9, //float reflectivity
            1.75 //float refractiveIndex
        );

        // Sphere 1
        spheres[9] = Sphere(
            vec3(cos(u_time)*0.5, sin(u_time)*0.5, 0.0), //vec3 center
            0.1,//float radius
            vec3(0.0, 1.0, 0.0), //vec3 color
            MATERIAL_REFLECTIVE,  //int material
            0.9,//float reflectivity
            0.9 //float refractiveIndex
        );

        // Sphere 2
        spheres[8] = Sphere(
            vec3(0.0, 0.5*sin(u_time)-0.25, 0.0), //vec3 center
            0.1,//float radius
            vec3(0.0, 0.0, 0.1), //vec3 color
            MATERIAL_REFRACTIVE,  //int material
            0.75,//float reflectivity
            1.7 //float refractiveIndex
        );
        
    }

    bool intersectSphere(Ray ray, Sphere sphere, out float t) {
        //Compute vector from ray origin to sphere center
        vec3 oc = ray.origin - sphere.center;
        
        //Set up quadratic equation
        float a = dot(ray.direction, ray.direction);
        float b = 2.0 * dot(oc, ray.direction);
        float c = dot(oc, oc) - sphere.radius*sphere.radius;
        
        //Solve discriminant
        float delta = b*b - 4.0*a*c;

        if(delta < 0.0){
            return false; //no intersection found
        }

        float t0 = (-b - sqrt(delta)) / (2.0 * a);
        float t1 = (-b + sqrt(delta)) / (2.0 * a);
        //if delta = 0 -> one intersection
        //if delta > 0 -> two intersections

        t = t0 > 0.001 ? t0 : t1;
        return t > 0.001;
    }

    bool intersectCube(Ray ray, Cube cube, out float t, out vec3 normal) {
        //Set up to determine the faces of the cube
        vec3 invDir = 1.0/(ray.direction + vec3(1e-8));
        vec3 cubeMin = cube.center - cube.size*0.5;//min corner
        vec3 cubeMax = cube.center + cube.size*0.5;//max corner

        //determine when the ray enters vs exits the cube
        vec3 t0 = (cubeMin - ray.origin)*invDir;
        vec3 t1 = (cubeMax - ray.origin)*invDir;

        vec3 tsmaller = min(t0, t1);
        vec3 tbigger  = max(t0, t1);

        float tmin = max(max(tsmaller.x, tsmaller.y), tsmaller.z);
        float tmax = min(min(tbigger.x, tbigger.y), tbigger.z);

        if (tmax < 0.001 || tmin > tmax) {
            return false;  //no intersection found
        }

        t = tmin > 0.001 ? tmin : tmax;

        //compute normal at hit point
        vec3 hitPoint = ray.origin + ray.direction*t;
        vec3 d = hitPoint - cube.center;
        vec3 absD = abs(d);

        //determine which face was hit
        if (absD.x > absD.y && absD.x > absD.z) {
            normal = vec3(sign(d.x), 0.0, 0.0);
        } else if (absD.y > absD.z) {
            normal = vec3(0.0, sign(d.y), 0.0);
        } else {
            normal = vec3(0.0, 0.0, sign(d.z));
        }

        return true;
    }

    // Trace objects in the scene for intersections
    HitData traceScene(Ray ray, bool includeLightSphere) {
        HitData closest;
        closest.hit = false;
        closest.t = 1e10;

        // Light sphere intersection
        if (includeLightSphere) {
            float t;
            if (intersectSphere(ray, lightSphere, t)) {//if the ray intersects a sphere
                if (t < closest.t) {
                    closest.hit = true;
                    closest.t = t;
                    closest.point = ray.origin + t*ray.direction;
                    closest.normal = normalize(closest.point - lightSphere.center);
                    closest.color = lightSphere.color;
                    closest.material = lightSphere.material;
                    closest.reflectivity = lightSphere.reflectivity;
                    closest.refractiveIndex = lightSphere.refractiveIndex;
                    closest.frontFace = dot(ray.direction, closest.normal) < 0.0;
                    if(!closest.frontFace) closest.normal = -closest.normal;
                }
            }
        }

        // Walls intersection
        /*
        for(int i = 0; i < walls.length(); i++){
            i = 4; //only back wall for now
            float cube_t;
            vec3 cubeNormal;
            if (intersectCube(ray, walls[i], cube_t, cubeNormal)) {
                if (cube_t < closest.t) {
                    closest.hit = true;
                    closest.t = cube_t;
                    closest.point = ray.origin + cube_t*ray.direction;
                    closest.normal = cubeNormal;
                    closest.color = walls[i].color;
                    closest.material = walls[i].material;
                    closest.reflectivity = walls[i].reflectivity;
                    closest.refractiveIndex = walls[i].refractiveIndex;
                    closest.frontFace = dot(ray.direction, closest.normal) < 0.0;
                    if(!closest.frontFace) closest.normal = -closest.normal;
                }
            }
        }
        */

        // Cube intersection
        for(int i = 0; i < cubes.length(); i++){
            float cube_t;
            vec3 cubeNormal;
            if (intersectCube(ray, cubes[i], cube_t, cubeNormal)) {
                if (cube_t < closest.t) {
                    closest.hit = true;
                    closest.t = cube_t;
                    closest.point = ray.origin + cube_t*ray.direction;
                    closest.normal = cubeNormal;
                    closest.color = cubes[i].color;
                    closest.material = cubes[i].material;
                    closest.reflectivity = cubes[i].reflectivity;
                    closest.refractiveIndex = cubes[i].refractiveIndex;
                    closest.frontFace = dot(ray.direction, closest.normal) < 0.0;
                    if(!closest.frontFace) closest.normal = -closest.normal;
                }
            }
        }

        // Sphere intersections
        for (int i = 0; i < spheres.length(); i++) {
            float t;
            if (intersectSphere(ray, spheres[i], t)) {
                if (t < closest.t) {
                    closest.hit = true;
                    closest.t = t;
                    closest.point = ray.origin + t*ray.direction;
                    closest.normal = normalize(closest.point - spheres[i].center);
                    closest.color = spheres[i].color;
                    closest.material = spheres[i].material;
                    closest.reflectivity = spheres[i].reflectivity;
                    closest.refractiveIndex = spheres[i].refractiveIndex;
                    closest.frontFace = dot(ray.direction, closest.normal) < 0.0;
                    if(!closest.frontFace) closest.normal = -closest.normal;
                }
            }
        }
        return closest;
    }

    vec3 refraction(vec3 I, vec3 N, float eta){
        //I -> incident ray direction
        //N -> surface normal direction
        //eta -> ratio of indices of refraction

        //snell's law: n1/n2 = sin(angle2)/sin(angle1)
        //n1/n2 = eta = sin(angle2)/sin(angle1)
        vec3 i = normalize(I);
        vec3 n = normalize(N);

        //check to ensure the ray is in the right direction
        float cosI = -dot(i, n);
        if(cosI < 0.0){
            cosI = -cosI;
            n = -n;
            eta = 1.0/eta;
        }

        float k = 1.0 - eta*eta * (1.0 - cosI*cosI);

        if(k < 0.0){
            return vec3(0.0);//total internal reflection
        }else{
            return normalize(eta*i + (eta*cosI - sqrt(k)) * n);
        }
    }

    // Schlick approximation
    float schlick(float cosine, float ref_idx) {
        float r0 = (1.0 - ref_idx) / (1.0 + ref_idx);
        r0 = r0*r0;
        return r0 + (1.0 - r0) * pow(1.0 - cosine, 5.0);
    }

    vec3 trace(Ray ray, int maxDepth) {
        vec3 color = vec3(0.0);

        //attenuation is optional
        vec3 attenuation = vec3(1.0);

        for (int depth = 0; depth < 8; depth++) {
            if (depth >= maxDepth) break;

            HitData hit = traceScene(ray, true);
            
            
            //HitData lightHit = traceScene(ray, true);
            if(hit.hit == true && hit.material == LIGHT_SOURCE){
                color += attenuation * hit.color;
                break;
            }
            
            if (!hit.hit) {
                //color += vec3(5.0/255.0, 1.0/255.0, 74.0/255.0);
                color += vec3(0.0);
                break;
            }

            //check shadow ray
            float bias = 0.001;

            vec3 lightDir = normalize(lightSphere.center - hit.point);
            float lightDist = length(lightSphere.center - hit.point);

            //shadowRay = Ray(hit + bias, lightDirection);
            Ray shadowRay = Ray(hit.point + hit.normal*bias, lightDir);
            //shadowHit = traceScene(shadowRay);
            HitData shadowHit = traceScene(shadowRay, false);
            
            //bool inShadow = true when it hits something before light
            bool inShadow = false;
            if(shadowHit.hit){
                if(shadowHit.t < lightDist){
                    inShadow = true;
                }
            }
            
            //if inShadow, dim down the light effect with shadowRatio in below
            float shadowRatio;
            if(inShadow){
                shadowRatio = 0.2;
            }else{
                shadowRatio = 1.0;
            }

            if (hit.material == MATERIAL_DIFFUSE) {
                //if hit.material == diffuse:
                //Direct light = hit.color * (l*n) * shadowRatio;
                vec3 directLight = hit.color * max(dot(hit.normal, lightDir), 0.0) * shadowRatio;

                //color = direct light + ambient light; break;
                vec3 ambientLight = hit.color * u_ambientStrength;
                color += attenuation * (directLight + ambientLight);
                break;

            } else if (hit.material == MATERIAL_REFRACTIVE) {
                float eta = 1.0/hit.refractiveIndex;
                
                vec3 reflectDir = reflect(ray.direction, hit.normal);
                vec3 refractDir = refraction(ray.direction, hit.normal, eta);
                bool total_internal_reflection = (refractDir == vec3(0.0));

                //Schlick() > 0.5 only reflection; < 0.5 only refraction
                //if total_internal_reflection or Schlick() > 0.5: only reflection;
                //else only refraction;
                float cosine = clamp(dot(-ray.direction, hit.normal), 0.0, 1.0);
                float schlick_value = schlick(cosine, eta);
                vec3 direction;

                if (total_internal_reflection || schlick_value > 0.5) {
                    //direction = reflection ray
                    direction = reflectDir;
                } else {
                    //direction = refraction ray
                    direction = refractDir;
                }

                vec3 directLight = hit.color * max(dot(hit.normal, lightDir), 0.0) *shadowRatio;
                vec3 ambientLight = hit.color * u_ambientStrength;
                color += attenuation * (directLight + ambientLight);

                //ray.origin = hit.point + hit.normal * bias;
                if(total_internal_reflection || schlick_value > 0.5){
                    ray.origin = hit.point + hit.normal*bias;
                }else{
                    ray.origin = hit.point - hit.normal*bias;
                }

                ray.direction = direction;
                attenuation *= hit.reflectivity;
            } else {
                //else:
                //continue tracing reflected ray
                //reflective surfaces = local illumination + reflected ray
                
                vec3 reflectDir = reflect(ray.direction, hit.normal);

                vec3 directLight = hit.color * max(dot(hit.normal, lightDir), 0.0) * shadowRatio;
                vec3 ambientLight = hit.color * u_ambientStrength;
                color += attenuation * (directLight + ambientLight);

                ray.origin = hit.point + hit.normal*bias;
                ray.direction = reflectDir;
                attenuation *= hit.reflectivity;
            }

            if (length(attenuation) < 0.01) break;
        }

        return color;
    }

    void main() {
        initScene(u_time);

        vec2 uv = (gl_FragCoord.xy - 0.5 * u_resolution) / u_resolution.y;

        vec3 origin = vec3(0.0, 0.0, 2.0);
        vec3 direction = normalize(vec3(uv, -1.5));

        Ray ray = Ray(origin, direction);
        vec3 color = trace(ray, u_maxBounces);

        color = pow(color, vec3(1.0 / 2.2));

        fragColor = vec4(color, 1.0);
    }
</script>

<script>
    (function() {
        const canvas = document.getElementById('glCanvas');
        gl = canvas.getContext('webgl2');

        if (!gl) {
            alert('WebGL 2 not supported in this browser');
            throw new Error('WebGL 2 not supported');
        }

        const vsEditor = document.getElementById('vsEditor');
        const fsEditor = document.getElementById('fsEditor');

        const vertexShaderSource = document.getElementById('vertex-shader').textContent;
        const fragmentShaderSource = document.getElementById('fragment-shader').textContent;

        // Initialize editors with shader source
        vsEditor.value = vertexShaderSource;
        fsEditor.value = fragmentShaderSource;

        let program, positionLocation, resolutionLocation, timeLocation, maxBouncesLocation, ambientStrengthLocation;
        let vao, positionBuffer;

        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);

            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                throw new Error(gl.getShaderInfoLog(shader));
            }

            return shader;
        }

        function createProgram(gl, vsSource, fsSource) {
            const vs = createShader(gl, gl.VERTEX_SHADER, vsSource);
            const fs = createShader(gl, gl.FRAGMENT_SHADER, fsSource);
            const prog = gl.createProgram();
            gl.attachShader(prog, vs);
            gl.attachShader(prog, fs);
            gl.linkProgram(prog);

            if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
                throw new Error(gl.getProgramInfoLog(prog));
            }

            return prog;
        }

        const positions = new Float32Array([
            -1, -1,
            1, -1,
            -1, 1,
            1, 1
        ]);

        // Initialize buffers
        function initBuffers() {
            positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

            vao = gl.createVertexArray();
            gl.bindVertexArray(vao);
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.enableVertexAttribArray(positionLocation);
            gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
            gl.bindVertexArray(null);
        }

        function initShaderProgram() {
            try {
                program = createProgram(gl, vsEditor.value, fsEditor.value);
                gl.useProgram(program);
                positionLocation = gl.getAttribLocation(program, 'position');
                resolutionLocation = gl.getUniformLocation(program, 'u_resolution');
                timeLocation = gl.getUniformLocation(program, 'u_time');
                maxBouncesLocation = gl.getUniformLocation(program, 'u_maxBounces');
                ambientStrengthLocation = gl.getUniformLocation(program, 'u_ambientStrength');
                
                initObjectUniforms(gl, program);
                initBuffers();
            } catch (e) {
                console.error(e);
            }
        }

        initShaderProgram();

        // Hot compile when any input in the playground text area
        vsEditor.onkeyup = initShaderProgram;
        fsEditor.onkeyup = initShaderProgram;

        let maxBounces = 4;
        let ambientStrength = 0.25;

        // UI Controls
        //<!-- insert your code here -->

        let startTime = Date.now();
        function render() {
            const time = (Date.now() - startTime) / 1000.0;

            gl.viewport(0, 0, canvas.width, canvas.height);
            gl.clearColor(0, 0, 0, 1);
            gl.clear(gl.COLOR_BUFFER_BIT);

            gl.useProgram(program);
            gl.bindVertexArray(vao);

            gl.uniform2f(resolutionLocation, canvas.width, canvas.height);
            gl.uniform1f(timeLocation, time);
            gl.uniform1i(maxBouncesLocation, maxBounces);
            gl.uniform1f(ambientStrengthLocation, ambientStrength);

            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

            requestAnimationFrame(render);

            const error = gl.getError();
            if(error !== gl.NO_ERROR){
                console.error("WebGL Error: ", error);
            }
        }

        requestAnimationFrame(render);
    })();
</script>

</body>
</html>