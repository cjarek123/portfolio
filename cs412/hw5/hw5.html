<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>UNM CS 412/512 HW5</title>
  <style>
    body {
      background: #111;
      color: #ccc;
      font-family: monospace;
    }

    textarea {
      background: #222;
      color: #0f0;
      font: 14px monospace;
      width: 400px;
      height: 250px;
    }

    canvas {
      border: 1px solid #444;
    }
  </style>
</head>

<body>
  <h2>Interactive Controls & Geometric Primitives</h2>
  <h3>Hold WASD to move the robotic arm.</h3>
  <div style="display: flex; gap: 10px; align-items: flex-start;">
    <div style="display: flex; flex-direction: column; gap: 10px;">
      <div>
        <b>Vertex Shader</b><br>
        <textarea id="vertEditor"></textarea>
      </div>
      <div>
        <b>Fragment Shader</b><br>
        <textarea id="fragEditor"></textarea>
      </div>
    </div>
    <div>
      <canvas id="glcanvas" width="550" height="550"></canvas>
    </div>
  </div>
  <br>
    <table>
      <tr style="vertical-align:top;">
        <tr><td>
          <select onchange="modeChanged()" id="select_id">
            <option value="1">normal mode</option>
            <option value="2">ambient only</option>
            <option value="3">diffuse only</option>
            <option value="4">specular only</option>
          </select>
        </td></tr>
        <tr>
          <td>Ambient reflection coefficient (ka):</td>
          <td id="slider-ka-value" width="30px">1.0</td>
          <td><div class="slidecontainer">
            <input type="range" min="0", max="1", step="0.01", value="1", class="slider", id="slider-ka">
          </div></td>
          <td>Ambient color:</td>
          <td><input type="color" id="colorSelectorAmbient" value="#ff0000">
          
            <td colspan="3">Light position:</td>
        </tr>
        <tr>
          <td>Diffuse reflection coefficient (kd):</td>
          <td id='slider-kd-value' width="30px">1.0</td>
          <td><div class="slidecontainer">
            <input type="range" min="0", max="1", step="0.01", value="1", class="slider", id="slider-kd">
          </div></td>
          <td>Diffuse Color:</td>
          <td><input type="color" id="colorSelectorDiffuse", value="#ff0000"></td>
          
          <td>X:</td>
          <td id="slider-x-value" width="30px">1</td>
          <td><div class="slidecontainer">
            <input type="range" min="-50", max="50", step="0.1", value="0", class="slider", id="slider-x">
          </div></td>
        </tr>
        <tr>
          <td>Specular reflection coefficient (ks):</td>
          <td id='slider-ks-value'  width="30px">1.0</td>
          <td><div class="slidecontainer">
            <input type="range" min="0", max="1", step="0.01", value="1", class="slider", id="slider-ks">
          </div></td>
          <td>Specular Color:</td>
          <td><input type="color" id="colorSelectorSpecular", value="#ff0000"></td>
          
          <td>Y:</td>
          <td id="slider-y-value"  width="30px">1</td>
          <td><div class="slidecontainer">
            <input type="range" min="-50", max="50", step="0.1", value="0", class="slider", id="slider-y">
            </div></td>
        </tr>
        <tr>
          <td>Shininess:</td>
          <td id='slider-s-value' width='30px'>4</td>
          <td><div class="slidecontainer">
            <input type="range" min="1", max="128", step="1", value="4", class="slider", id="slider-s">
          </div></td>
          <td>Background Color:</td>
          <td><input type="color" id="colorSelector", value="#ffffff"></td>
          
          <td>Z:</td>
          <td id='slider-z-value'  width='30px'>-1</td>
          <td><div class="slidecontainer">
            <input type="range" min="-50", max="50", step="0.1", value="-1", class="slider", id="slider-z">
          </div></td>
        </tr>
      </table>
  </div>

  <!-- Vertex shader -->
  <script id="vertex-shader" type="x-shader/x-vertex">#version 300 es
  in vec3 aPosition;
  in vec3 aColor;
  in vec3 aNormal;
  in vec2 aTextureCoord;

  uniform float uTime; //time in sec
  uniform mat4 uModelViewMatrix;
  uniform mat4 uProjectionMatrix;
  uniform mat4 uModelTransformationMatrix;

  out vec2 vTextureCoord;
  out vec3 vNormal;
  out vec3 vFragPos;
  out vec3 vColor;

  void main() {
    vec4 worldPos = uModelViewMatrix * uModelTransformationMatrix * vec4(aPosition, 1.0);
    vFragPos = worldPos.xyz;

    mat3 normalMatrix = transpose(inverse(mat3(uModelViewMatrix * uModelTransformationMatrix)));
    vNormal = normalize(normalMatrix * aNormal);

    gl_Position = uProjectionMatrix * worldPos;
    vTextureCoord = aTextureCoord;
    vColor = aColor;
  }
</script>
  <!-- Fragment Shader -->
  <script id="fragment-shader" type="x-shader/x-fragment">#version 300 es
  precision mediump float;

  in vec3 vNormal;
  in vec3 vFragPos;
  in vec3 vColor;
  in vec2 vTextureCoord;

  uniform vec3 uLightPos;
  uniform float uKa;
  uniform float uKd;
  uniform float uKs;
  uniform float uShininess;
  uniform vec3 uAmbientColor;
  uniform vec3 uDiffuseColor;
  uniform vec3 uSpecularColor;
  uniform int uMode;
  uniform sampler2D uSampler;

  out vec4 fragColor;

  void main() {
    vec3 normal = normalize(vNormal);
    vec3 lightDir = normalize(uLightPos - vFragPos);

    vec3 ambient = uKa*uAmbientColor;

    float diff = max(dot(normal, lightDir), 0.0);
    vec3 diffuse = uKd * diff * uDiffuseColor;

    vec3 viewDir = normalize(-vFragPos);
    vec3 reflectDir = reflect(-lightDir, normal);
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), uShininess);
    vec3 specular = uKs * spec * uSpecularColor;

    vec3 result;
    if(uMode == 2) result = ambient;
    else if(uMode == 3) result = diffuse;
    else if(uMode == 4) result = specular;
    else result = ambient + diffuse + specular;

    vec4 texColor = texture(uSampler, vTextureCoord);
    fragColor = texColor * vec4(vColor, 1.0) * vec4(result, 1.0);
  }
</script>
  <script src="primitives.js"></script>
  <script src="transformations.js"></script>
  <script src="myTransformations.js"></script>
  <script src="myBuffers.js"></script>
  <script src="textures.js"></script>
  <script src="lighting.js"></script>
  <script>
    function createShader(gl, type, source) {
      let shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        throw new Error(gl.getShaderInfoLog(shader));
      }
      return shader;
    }

    function createProgram(gl, vsSource, fsSource) {
      let vs = createShader(gl, gl.VERTEX_SHADER, vsSource);
      let fs = createShader(gl, gl.FRAGMENT_SHADER, fsSource);
      let prog = gl.createProgram();
      gl.attachShader(prog, vs);
      gl.attachShader(prog, fs);
      gl.linkProgram(prog);
      if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
        throw new Error(gl.getProgramInfoLog(prog));
      }
      return prog;
    }

    // WebGL setup
    const canvas = document.getElementById("glcanvas");
    const gl = canvas.getContext("webgl2");
    if (!gl) alert("WebGL2 not supported");

    let vertEditor = document.getElementById("vertEditor");
    let fragEditor = document.getElementById("fragEditor");
    vertEditor.value = document.getElementById("vertex-shader").textContent;
    fragEditor.value = document.getElementById("fragment-shader").textContent;

    //Shader variables
    let program, posLoc, colorLoc, uMVM, uPM, uMTM;
    let vbo, nbo, ibo;
    let positionBuffer, colorBuffer, indexBuffer;

    //Lighting variables
    let uLightPos, uKa, uKd, uKs, uShininess;
    let uAmbientColor, uDiffuseColor, uSpecularColor, uMode;

    //Texture variables
    let vertexPos, textureCoord, projectionMatrix, modelViewMatrix, sampler;

    // Buffers
    const myBuffers = initMyBuffers(objects);

    //Load textures
    const texture = loadTexture(gl, "https://cc0-textures.com/t/st-abstract-2");

    function initShaderProgram() {
      try {
        program = createProgram(gl, vertEditor.value, fragEditor.value);
        gl.useProgram(program);
        posLoc = gl.getAttribLocation(program, "aPosition");
        colorLoc = gl.getAttribLocation(program, "aColor");
        normalLoc = gl.getAttribLocation(program, "aNormal");
        textureLoc = gl.getAttribLocation(program, "aTextureCoord");
        timeLoc = gl.getUniformLocation(program, "uTime");
        uMVM = gl.getUniformLocation(program, "uModelViewMatrix");
        uPM = gl.getUniformLocation(program, "uProjectionMatrix");
        uMTM = gl.getUniformLocation(program, "uModelTransformationMatrix");

        uLightPos = gl.getUniformLocation(program, "uLightPos");
        uKa = gl.getUniformLocation(program, "uKa");
        uKd = gl.getUniformLocation(program, "uKd");
        uKs = gl.getUniformLocation(program, "uKs");
        uShininess = gl.getUniformLocation(program, "uShininess");
        uAmbientColor = gl.getUniformLocation(program, "uAmbientColor");
        uDiffuseColor = gl.getUniformLocation(program, "uDiffuseColor");
        uSpecularColor = gl.getUniformLocation(program, "uSpecularColor");
        uMode = gl.getUniformLocation(program, "uMode");
        sampler = gl.getUniformLocation(program, "uSampler");

        console.log("Shader Locations:", {
          posLoc, colorLoc, normalLoc, textureLoc,
          timeLoc, uMVM, uPM, uMTM,
          uLightPos, uKa, uKd, uKs, uShininess,
          uAmbientColor, uDiffuseColor, uSpecularColor, uMode, sampler
        });
      } catch (e) { console.error(e); }
    }
    initShaderProgram();
    vertEditor.onkeyup = initShaderProgram;
    fragEditor.onkeyup = initShaderProgram;
    
    //Lighting setup
    updateAllLightingUniforms();

    // Mouse and keyboard interactions
    let mouseDown = false, lastX, lastY, cubeRotX = 0, cubeRotY = 0;
    let camX = 0, camY = -2.5, camZ = -10;
    
    function clamp(value, min, max){
      return Math.min(Math.max(value, min), max);
    }

    //my mouse and keyboard vars
    let armMovementX = 1.0;
    let armMovementY = 1.0;
    let armRotation = 0.0;
    let grab = 0.0;
    const minX = 1.0;
    const maxX = 8.0;
    const minY = 0.0;
    const maxY = 6.0;
    
    //my event listners
    document.addEventListener('keydown', e => {
      const armStep = 0.1;
      const armRotStep = Math.PI/80.0;
      switch(e.key){
        case 'w': armMovementX = clamp(armMovementX+armStep, minX, maxX); 
                  armMovementY = clamp(armMovementY+armStep, minY, maxY); break;//move arm up and out
        case 's': armMovementX = clamp(armMovementX-armStep, minX, maxX); 
                  armMovementY = clamp(armMovementY-armStep, minY, maxY); break;//move arm down and in
        case 'a': armRotation -= armRotStep; break;//rotate arm1 left
        case 'd': armRotation += armRotStep; break;//rotate arm1 right
        case '0': grab = 2*Math.PI; break;//grabbers
      }
    });

    //fov projection matrix
    let fov = Math.PI / 4, aspect = canvas.width / canvas.height, zNear = 0.1, zFar = 100;
    let f = 1 / Math.tan(fov / 2);
    let proj = new Float32Array([
      f / aspect, 0, 0, 0, 0, f, 0, 0, 0, 0, (zFar + zNear) / (zNear - zFar), -1, 0, 0, (2 * zFar * zNear) / (zNear - zFar), 0
    ]);

    let startTime = Date.now();

    function render() {
      gl.enable(gl.DEPTH_TEST);
      gl.clearColor(0, 0, 0, 1);
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

      //Lighting uniforms
      gl.uniform3f(uLightPos,
        parseFloat(lightPositionX.value),
        parseFloat(lightPositionY.value),
        parseFloat(lightPositionZ.value));
      gl.uniform1f(uKa, parseFloat(ambientSlider.value));
      gl.uniform1f(uKd, parseFloat(diffuseSlider.value));
      gl.uniform1f(uKs, parseFloat(specularSlider.value));
      gl.uniform1f(uShininess, parseFloat(shininessSlider.value));
      const ambientCol = hexToRGB(ambientColor.value);
      const diffuseCol = hexToRGB(diffuseColor.value);
      const specularCol = hexToRGB(specularColor.value);
      gl.uniform3f(uAmbientColor, ambientCol[0], ambientCol[1], ambientCol[2]);
      gl.uniform3f(uDiffuseColor, diffuseCol[0], diffuseCol[1], diffuseCol[2]);
      gl.uniform3f(uSpecularColor, specularCol[0], specularCol[1], specularCol[2]);
      gl.uniform1i(uMode, parseInt(document.getElementById("select_id").value));

      // Bind texture
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.uniform1i(sampler, 0);

      // rotation matrices
      let cx = Math.cos(cubeRotY), sx = Math.sin(cubeRotY);
      let cy = Math.cos(cubeRotX), sy = Math.sin(cubeRotX);
      let rotX = [1, 0, 0, 0, 0, cy, sy, 0, 0, -sy, cy, 0, 0, 0, 0, 1];
      let rotY = [cx, 0, -sx, 0, 0, 1, 0, 0, sx, 0, cx, 0, 0, 0, 0, 1];
      let cubeRotation = multiplyMat4(rotY, rotX);

      // init model-view matrix as identity matrix
      let modelViewMatrix = mat4Identity();
      // init model transformation matrix as identity matrix
      let modelTransformationMatrix = mat4Identity();

      //delta time in ms
      let deltaTime = Date.now() - startTime;
            // object rotation
      modelTransformationMatrix = multiplyMat4(modelTransformationMatrix, cubeRotation);
      // camera translation
      modelViewMatrix = mat4Translate(modelViewMatrix, [camX, camY, camZ]);
      
      //set time in seconds
      gl.uniform1f(timeLoc, deltaTime/1000.0);
      gl.uniformMatrix4fv(uPM, false, proj);
      gl.uniformMatrix4fv(uMVM, false, modelViewMatrix);
      gl.uniformMatrix4fv(uMTM, false, modelTransformationMatrix);

      
      bindMyBuffers(myBuffers, deltaTime, armMovementX, armMovementY, armRotation, grab,
      modelViewMatrix, modelTransformationMatrix);

      const error = gl.getError();
      if(error !== gl.NO_ERROR){
        console.error("WebGL Error: ", error);
      }
    }

    // Initialize when page loads
    window.onload = function () {
      setInterval(render, 30);
    }

  </script>
</body>

</html>